# Celeste Code Mod 开发日志

## 这一阶段在做什么
我打算先找到一个合适的方法来实现影子玩家，让他可以追随玩家的操作，然后再考虑如何应用到网络流中，用网络流控制这个影子玩家，进而实现多人游戏

## 有关于影子玩家的一些想法
（本部分的实现有参考于[EverestAPI/GhostMod](https://github.com/EverestAPI/GhostMod)的实现）

影子玩家应当也是一个实体(`Entity`)，我的第一想法是使用`PlayerPlayback`来实现，这是一个游戏本身提供的继承自`Entity`的类，他的作用是播放玩家的一段预先录制好的操作，这个实现在官图9A中，教学凌波微步的时候有使用到，我认为控制他会要方便许多

但是这个产生了许多问题，会导致地图无法加载，或者是切板时出现问题，严重影响游戏，而且这个类产生出来的“影子玩家”的效果就是官图中的那种（不能看见Madeline，只能看见代表冲刺次数的背景颜色），这种效果并不是我想要的（因为不能够显示出一个完整的Madeline形象）

随后考虑直接使用`Player`类，尝试强制修改实例的精灵，但是这个方法并不可行，这样最直观的是无法正常显示影子玩家，即便可以显示，也会导致在切板时出现闪屏的问题（这个闪屏是由于存在了两个`Player`实例，导致场景切换时要分别针对每个`Player`实例播放切板动画，会导致摄像机晃来晃去，玩家本身控制的即无法正常切板，进而跟随玩家的影子玩家也没办法正常切板，玩家本身会导致切板失败失去控制而下滑，但是仍然在应当切板的范围内，所以重复播放了玩家本身的切板动画，然后再次出现上面的问题），尝试继承自这个`Player`类，然后再自己构造的类中强制修改他的一些逻辑，效果依旧。

最后参考了`GhostMod`的实现方案，他的方法是仿照`Player`类，从`Actor`类继承并自己构造一个简化的玩家类（比如一些计时器，对于影子玩家来说是不需要的，他只需要跟随玩家本身的位置就可以了），有这个参考之后，在目前的目标下精简他的实现，最后成功实现了影子玩家的部分基础逻辑，接下来会尽可能详细的描述这种方案的实现

## 实现影子玩家的一些细节
### 1. 为什么要继承自`Actor`类
就目前的理解来看，`Actor`类是游戏中可动的实体的基类（例如Madeline，Badline），在尝试实例化`Player`类时，他的构造函数中会传入一个`PlaySpriteMode`，也就是精灵类型，因此认为所有`“会动的”`实体（这里指的是可以随意动的，而不是固定路径动的，机关不算这种实体）都应该继承自`Actor`类，并给他们设置相应的警铃类型，这样可以保证他们在游戏中可以正常显示
### 2. 为什么没有明确设置自有类的贴图，他就能够正常显示？
在本仓库提及的教程中提到如下的内容：
    
    继承链:
    Sprite -> Image -> GraphicsComponent -> Component

也就是说，只要构造`Sprite`传入正确的mode，他就可以自动的应用相应的贴图和动画
### 3. 角色朝向问题
我认为这个应当是值得单拿出来的一个点来说明

开门见山，解决方案是这样的：

```csharp
Sprite.Scale.X *= (float)Facing;
```

首先需要明确的是，`Player`类中有一个`Facing`枚举，用来表示角色的朝向，但是这个枚举并不是`Actor`类的一部分，也就是说，`Actor`类并没有这个枚举。游戏中影子玩家正确的朝向是很重要的（至少在联机情况下，能够反映正确的朝向才是正确的反馈）

如果我们在自己的类中，就算你在自己的类中明确定义了这个枚举，也是没有办法在游戏调用链条中正确的反应出来，因为在游戏的调用链条中，他并不能感知到我们自己定义的这个枚举，所以才有上面的“骚操作”，这部分参考自`GhostMod`的实现，至于Scale是什么，我也不是很清楚，但是这个操作是有效的，可以正确的反应出影子玩家的朝向

## 结尾
一定要使用`dnSpy`或者`ILSpy`这样的工具来查看游戏的源代码，这样可以帮助你更好的理解游戏的运行逻辑，尤其是某些类的某些变量，他都在哪些方法中使用到了，或者是在哪些方法中被修改了，根据这些信息可以理顺出游戏的完整调用链，明白什么情况下一些事件才会被触发，这对于Mod开发是非常有帮助的